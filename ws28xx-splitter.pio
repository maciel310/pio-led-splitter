.program ws28xx_reset_watch

; The signal can be high for as short as 0.5 microseconds, so we must sample
; at least every 0.25 microseconds to not miss a high value (nyquist theorem).
; This equates to 4MHz, but since we sample every other cycle in the loop (the
; other cycle we're decrementing the counter), we must run at at least 8Mhz.
; For simpler math the divider is set so we run at 10MHz
;
; At 10MHz, each instruction takes 100 ns.
; We're looking for the pin to stay low for at least 50 microseconds,
; meaning it needs to stay low for at least 500 cycles.
; The loop body takes 2 cycles per iteration, so initializing iterating 250
; times gives us the 50 microsecond timer.

MOV OSR, !NULL   ; Fill the OSR with ones
OUT X, 8         ; Shift 8 ones into X (set value to 255);
MOV OSR, X       ; Save the 255 value into OSR for easy reloading

.wrap_target

one_found:
MOV X, OSR          ; Restore loop target count into scratch register
timer_loop:
JMP PIN one_found   ; Start over if we see a one.
JMP X-- timer_loop  ; If X decrements to 0 then the total time has passed.

IRQ SET 0           ; Raise IRQ when reset happens so other state machine can react.

WAIT 1 PIN 0        ; Wait for a one before restarting countdown.

.wrap

% c-sdk {

static inline void ws28xx_reset_watch_init(PIO pio, uint sm, uint offset, uint source_pin) {
    pio_sm_config c = ws28xx_reset_watch_program_get_default_config(offset);

    // Divide the 125MHz clock down to 10Mhz
    sm_config_set_clkdiv_int_frac8(&c, 12, 128);

    pio_gpio_init(pio, source_pin);

    // Configure input pin direction
    pio_sm_set_consecutive_pindirs(pio, sm, source_pin, 1, true);

    sm_config_set_in_pins(&c, source_pin);
    sm_config_set_jmp_pin(&c, source_pin);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}


.program ws28xx_splitter

.wrap_target


PULL BLOCK     ; First message is the GPIO bitmask, indicating which PINS should be high.
MOV ISR, OSR   ; Copy the strand bitmask to ISR so it can be bitshifted.
main_loop:
    IN NULL, 1     ; Shift strand bitmask over by 1
    MOV Y, ISR     ; Copy to scratch for conditional jump
    JMP !Y done    ; Once the bit has been shifted off this will be 0, and jump out of the loop.

    PULL BLOCK     ; Get the number of pixels in this strand
    MOV Y, OSR     ; Copy into Y scratch register
strand_loop:
    SET X, 23
bit_loop:
        WAIT 1 PIN 0
        MOV PINS, ISR
        WAIT 0 PIN 0
        MOV PINS, NULL
        JMP X-- bit_loop

    JMP Y-- strand_loop    ; Loop until we're out of pixels in this strand

    JMP main_loop  ; Unconditional jump, will explicitly jump out when done.

done:
NOP

.wrap

% c-sdk {

static inline void ws28xx_splitter_init(PIO pio, uint sm, uint offset, uint source_pin, uint out_start_pin, uint out_pin_count) {
    pio_sm_config c = ws28xx_splitter_program_get_default_config(offset);

    pio_gpio_init(pio, source_pin);
    for (int i = 0; i < out_pin_count; i++) {
        pio_gpio_init(pio, out_start_pin + i);
    }

    // Configure input pin direction
    pio_sm_set_consecutive_pindirs(pio, sm, source_pin, 1, true);
    // Configure output pins direction
    pio_sm_set_consecutive_pindirs(pio, sm, out_start_pin, out_pin_count, true);

    sm_config_set_in_pins(&c, source_pin);
    sm_config_set_out_pins(&c, out_start_pin, out_pin_count);
    sm_config_set_set_pins(&c, out_start_pin, out_pin_count);

    sm_config_set_in_shift(&c, /*shift_right=*/ true, /*autopush=*/ false, 0);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

// Reset handler to restart state machine. Called when ws28xx reset condition is met.
static inline void ws28xx_splitter_reset(PIO pio, uint sm, uint offset) {
    pio_sm_set_enabled(pio, sm, false);
    pio_sm_restart(pio, sm);
    pio_sm_clear_fifos(pio, sm);
    pio_sm_exec(pio, sm, pio_encode_jmp(offset));
    pio_sm_set_enabled(pio, sm, true);
}
%}
