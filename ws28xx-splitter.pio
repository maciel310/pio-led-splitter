.program ws28xx_splitter

.wrap_target

set x, 5
mov OSR, x ; Temporary - move this to pull from the FIFO
set x, 1
mov ISR, x    ; use the ISR as the pin value, since we can shift 0's into it each loop

allloop:
mov y, OSR    ; Copy pixel count from OSR to y
strandloop:
    set x, 24
bitloop:
        wait 1 pin 0
        ; SET PINS, 1
        MOV PINS, ISR
        wait 0 pin 0
        ; SET PINS, 0
        MOV PINS, NULL
        jmp x-- bitloop

    jmp y-- strandloop
IN NULL, 1
MOV Y, ISR
SET X, 0b1000
JMP X!=Y allloop

.wrap

% c-sdk {

static inline void ws28xx_splitter_init(PIO pio, uint sm, uint offset, uint source_pin, uint out_start_pin, uint out_pin_count) {
    pio_sm_config c = ws28xx_splitter_program_get_default_config(offset);

    pio_gpio_init(pio, source_pin);
    for (int i = 0; i < out_pin_count; i++) {
        pio_gpio_init(pio, out_start_pin + i);
    }

    // Configure input pin direction
    pio_sm_set_consecutive_pindirs(pio, sm, source_pin, 1, true);
    // Configure output pins direction
    pio_sm_set_consecutive_pindirs(pio, sm, out_start_pin, out_pin_count, true);

    sm_config_set_in_pins(&c, source_pin);
    sm_config_set_out_pins(&c, out_start_pin, out_pin_count);
    sm_config_set_set_pins(&c, out_start_pin, out_pin_count);

    sm_config_set_in_shift(&c, /*shift_right=*/ false, /*autopush=*/ false, 0);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
